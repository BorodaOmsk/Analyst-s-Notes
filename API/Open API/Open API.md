## Что такое Open API? Преимущества, недостатки и примеры

![alt text](/API/Open%20API/image/image10.png)

## Оглавление:

- [Что такое OpenAPI?](#что-такое-openapi)
  - [1."...определяет стандарт...":](#1определяет-стандарт)
  - [2. «…независимый от языка интерфейс для RESTful API…»:](#2-независимый-от-языка-интерфейс-для-restful-api)
  - [3. "...что позволяет как людям, так и компьютерам обнаружить и понять возможности сервиса...":](#3-что-позволяет-как-людям-так-и-компьютерам-обнаружить-и-понять-возможности-сервиса)
  - [4. "...без доступа к исходному коду, документации или путем проверки сетевого трафика".](#4-без-доступа-к-исходному-коду-документации-или-путем-проверки-сетевого-трафика)
- [Почему OpenAPI является популярным стандартом?](#почему-openapi-является-популярным-стандартом)
- [Как OpenAPI определяет API?](#как-openapi-определяет-api)
- [Формат OpenAPI](#формат-openapi)
- [Типы данных](#типы-данных)
- [Structure](#structure)
- [Schemas](#schemas)
- [Сильные стороны OpenAPI](#сильные-стороны-openapi)
- [Слабые стороны OpenAPI](#слабые-стороны-openapi)
  - [Менее полезно для проектирования и планирования API.](#менее-полезно-для-проектирования-и-планирования-api)
  - [Не иерархический](#не-иерархический)
  - [Не поддерживает наследование модели данных](#не-поддерживает-наследование-модели-данных)
  - [Не "визуальный" инструмент](#не-визуальный-инструмент)
  - [Отсутствие поддержки других архитектур](#отсутствие-поддержки-других-архитектур)
- [Пример OpenAPI - зоомагазин Swagger](#пример-openapi---зоомагазин-swagger)


# Что такое OpenAPI?


По данным SmartBear, материнской компании Swagger:

"**Спецификация OpenAPI**(OAS) определяет стандарт, не зависящий от языка интерфейс для RESTful API, который позволяет людям и компьютерам обнаруживать и понимать возможности сервиса без доступа к исходному коду, документации или посредством проверки сетевого трафика".

Это очень сложно. Давайте разделим описание SmartBear на более мелкие кусочки:

## 1."...определяет стандарт...":

Спецификация OpenAPI определяет структуру API, которая также описывает API.

## 2. «…независимый от языка интерфейс для RESTful API…»:

- API REST используют протокол HTTP для передачи данных. Этот протокол позволяет взаимодействовать платформам и системам, написанным на разных языках программирования.
- OpenAPI работает только с RESTful API, а не с другими типами API.

## 3. "...что позволяет как людям, так и компьютерам обнаружить и понять возможности сервиса...":

- Люди могут читать документацию, созданную непосредственно на основе определения API в OAS.
- Клиент понимает, как он может отправлять запросы и как серверы API отвечают на эти запросы, основываясь на определении API.

## 4. "...без доступа к исходному коду, документации или путем проверки сетевого трафика".

В OpenAPI клиентское приложение и сервер API разделены. Определение API сервиса определяет, как клиенты могут взаимодействовать с ним, без необходимости читать его исходный код.

Подводя итог, можно сказать, что OpenAPI - это спецификация RESTful API, описывающая API, которые соответствуют архитектуре RESTful. Спецификация предоставляет интерфейс, позволяющий людям и компьютерам понять API и то, как с ним взаимодействовать.

# Почему OpenAPI является популярным стандартом?

Существует несколько спецификаций, описывающих RESTful API. OpenAPI - одна из самых известных и широко используемых. Два других формата, используемых для REST API, - это RAML и API Blueprint. Мы рассмотрим преимущества и недостатки OpenAPI в сравнении позже. Хотя OpenAPI можно считать отраслевым стандартом, в конечном итоге компании часто выбирают тот формат, который лучше всего соответствует их бизнес-потребностям.

В связи с этим возникает вопрос: если существует несколько форматов для описания REST API, почему OpenAPI такой особенный? Ключевым фактором популярности OpenAPI является его принятие. Более широкое распространение приводит к большей поддержке сообщества, созданию надежных инструментов и более эффективному управлению.

Компания может использовать спецификацию OpenAPI благодаря ее переносимости и простоте. OpenAPI "не зависит от языка" и определяет общий язык для взаимодействия клиент-сервер. Он хорошо совместим с системами, написанными на различных языках программирования. OpenAPI также хорошо читаем как людьми, так и компьютерами и пользуется поддержкой большого, растущего сообщества.

Другой популярный формат - RAML, язык моделирования API, ориентированный на определение и проектирование API (хотя вы можете проектировать API с помощью OpenAPI). Может показаться, что возможности RAML превосходят OpenAPI. Его преимущество в том, что он иерархичен и поддерживает наследование моделей данных. Однако RAML не так широко распространен, как OpenAPI. Несмотря на то что у RAML есть специализированное сообщество, его поддержка не столь велика. У RAML есть инструментарий, но есть некоторые признаки того, что в последних версиях отсутствует необходимая поддержка.

Помимо RAML, еще одной альтернативой OpenAPI является API Blueprint. API Blueprint фокусируется на понятной документации с опорой на формат markdown, а не на JSON (как OpenAPI) или YAML (как OpenAPI и RAML). Из-за низкого уровня распространения API Blueprint не имеет поддержки сообщества и надежных инструментов для OpenAPI. Интегрировать API Blueprint во весь жизненный цикл API сложно, так как его единственным направлением является документирование.

В целом, OpenAPI является самым популярным стандартом для описания API. Хотя у него есть недостатки, OpenAPI, скорее всего, будет набирать популярность, в то время как долгосрочная жизнеспособность других типов спецификаций неясна.

# Как OpenAPI определяет API?

Подумайте о документе со спецификацией, который вы бы прочитали в Сonfluence. Этот документ со спецификацией обеспечивает широкий контекст системы и описывает ее компоненты и взаимодействие с другими системами.

Структура унаследованных спецификаций часто бывает разной. Спецификация API, например OpenAPI, имеет строгую структуру. Если спецификация API соответствует другому формату, например RAML или API Blueprint, то документация имеет структуру, соответствующую этому формату.

Возвращаясь к тому, как OpenAPI определяет API, вы часто будете слышать, как «спецификация» и «определение» используются как синонимы. Спецификация API «определяет» API. Читая спецификацию API, вы узнаете о типах запросов, которые вы можете отправлять, и о том, какие ответы вы ожидаете получить от API. Кроме того, в спецификации описаны доступные опции, влияющие на возвращаемую информацию. Как и в устаревшей спецификации, вы узнаете о системе, ее компонентах и ​​взаимодействиях.Еще одно различие между устаревшими спецификациями и спецификациями API заключается в том, что спецификации API являются динамическими. Всякий раз, когда изменяется базовый исходный код API, документация обновляется. Устаревшие документы спецификаций требуют ручного обновления документов Word при каждом изменении системы.

# Формат OpenAPI

Прежде чем понять структуру спецификации OpenAPI, необходимо разобраться в формате документа OpenAPI. В отличие от устаревших спецификаций, написанных в Сonfluence, формат OpenAPI - JSON. Хотя обсуждение нюансов JSON выходит за рамки этой статьи, думайте о JSON как о способе представления данных API в виде пар ключ-значение.

Например, в старых спецификациях вы бы написали заголовок спецификации (включая название системы), используя стиль Title на титульной странице. С другой стороны, чтобы написать заголовок спецификации OpenAPI, вы напишете его в виде пары ключ-значение в формате JSON.

Теперь подумайте обо всей информации об API. Его методы, операции, ответы и т. д. Представьте, что все эти свойства документированы в виде серии таких пар ключ-значение, которые соответствуют структуре OpenAPI.

Примечание: Хотя стандартным форматом для OpenAPI является JSON, можно представить OpenAPI в более простом формате YAML (аббревиатура, означающая YAML ain't markup language).

---

{

    "title": "My API Name"

}

---

# Типы данных

Как объект JSON, спецификация OpenAPI поддерживает типы данных, определенные в более широкой спецификации JSON Schema Specification. Примитивы включают integers, numbers, booleans, и strings. Вы можете объявить формат типа данных с помощью модификатора свойства format. Например, вы можете объявить целое число в формате int32 или int64, число в формате float или double или строку в формате двоичных данных, данных, даты и времени или пароля. OpenAPI также поддерживает модели (объекты), определенные в более широкой спецификации JSON, в виде объектов схемы.

Важно отметить, что JSON - это основной формат, который REST API используют для отправки и получения информации.

# Structure

На данный момент мы понимаем, что:

- Спецификация OpenAPI - это объект в формате JSON.
- Свойства API - это набор пар ключ-значение.
- Значения - это типы данных, определенные более широкой спецификацией JSON.
  
Теперь пришло время обсудить структуру OpenAPI.

Как уже говорилось, документ OpenAPI строго структурирован. Объекты или массивы объектов группируют связанные пары ключ-значение. Высокоуровневые объекты спецификации OpenAPI похожи на главы в унаследованном документе спецификации.

Ниже приведен шаблон OpenAPI со свернутыми секциями, чтобы показать общую структуру. В каждом разделе есть свойства, или пары ключ-значение, которые предоставляют метаданные об API.

![alt text](/API/Open%20API/image/image1.png)

Верхний уровень OpenAPI, обозначенный первыми скобками { }, называется "объектом документа", потому что он содержит все свойства OpenAPI.

Хотя документы OpenAPI должны соответствовать базовой структуре, OpenAPI предлагает некоторую гибкость. Некоторые из разделов высокого уровня являются обязательными, а другие - нет. Вы заметите, что спецификации OpenAPI для разных API могут выглядеть немного по-разному.

Документ OpenAPI может содержать следующие разделы:

- **Openapi** - Обязательное поле, определяющее версию спецификации OpenAPI для API. Инструменты используют номер версии для разбора спецификации OpenAPI, например, для создания документации.
- **Info** - обязательное поле, содержащее метаданные. Инструментарий может использовать метаданные различными способами.
- **Servers** - Массив объектов серверов. Каждый объект сервера содержит сведения о подключении к серверу. Этот объект содержит URL-адрес хоста сервера и описание сервера.
- **Paths** - обязательный объект, содержащий относительные пути к отдельным конечным точкам API. Для данного пути доступны такие операции взаимодействия с API, как POST, GET, PUT или DELETE.
- **Components** — объект, который содержит повторно используемые схемы для тел запросов, схем ответов и схем безопасности. Ссылки на схемы в этом разделе упоминаются в определенных частях спецификации, например в объекте пути, с использованием тега $ref.
- **Security** – объект, который объявляет тип схемы безопасности, разрешающей запросы. Объект безопасности определяется глобально или переопределяется отдельными операциями (переопределение схемы безопасности).
- **Tags** - объект, содержащий метаданные. Инструменты, разбирающие спецификацию, могут использовать этот объект. Например, вы можете указать порядок отображения каждого ресурса API в документации API (а не в алфавитном порядке).
- **ExternalDocs** - объект, предоставляющий ссылки на дополнительную документацию. Вы можете использовать этот объект, чтобы добавить ссылку на руководство пользователя.

# Schemas

В нижней части документации по API обычно есть раздел Schemas, который соответствует схемам, описанным в разделе компонентов определения API.

Этот раздел представляет собой краткий глоссарий для тех случаев, когда читателю необходимо просмотреть общие схемы в более широком контексте API (а не их использование в конкретных операциях). Схемы - это объекты, содержащие свойства/метаданные.

В следующем разделе схем для Swagger Petstore показаны схемы, относящиеся к конкретным операциям. Заказ - это схема, представляющая заказ, оформленный на питомца в зоомагазине Swagger. Каждый заказ имеет свои метаданные, включая его Id, дату отправки и статус заказа.

![alt text](/API/Open%20API/image/image2.png)

# Сильные стороны OpenAPI

OpenAPI имеет следующие преимущества:

- **Понятная документация** - OpenAPI известен своей легко читаемой документацией для людей и компьютеров.
- **Независимость от языка**— клиенты могут взаимодействовать с серверами API, не зная реализации сервера. Другие форматы, такие как API Blueprint, требуют наличия стороннего кода на сервере и не предоставляют вам этот код.
- Управление - Инициатива OpenAPI поддерживает стандарт OpenAPI и модерируется лидерами отрасли.
- **Широкое распространение** - OpenAPI является самым популярным форматом для описания REST API. Масштабы его распространения указывают на то, что OpenAPI - это надолго. Спецификация, подобная API Blueprint, страдает от недостатка принятия.
- Надежные инструменты - Будучи наиболее широко поддерживаемым форматом, в настоящее время существует множество инструментов, использующих OpenAPI для создания документации, тестирования и т.д. Другие спецификации не имеют поддержки и сопровождения OpenAPI для создания инструментов.

# Слабые стороны OpenAPI

У каждого типа спецификаций есть свои сильные и слабые стороны. Здесь мы сосредоточимся на недостатках OpenAPI по сравнению с его ближайшим конкурентом, RAML.

## Менее полезно для проектирования и планирования API.

При разработке API на основе OpenAPI можно использовать подход "сначала спецификация". Этот подход предполагает написание спецификации OpenAPI для API "от руки" или с помощью инструмента проектирования. Используя этот подход, вы разрабатываете спецификацию API, а затем используете ее в качестве "контракта" при создании API. Противоположностью "spec-first" является использование OpenAPI для создания документации без использования его в качестве инструмента проектирования.

Хотя подход "spec-first" имеет много преимуществ, OpenAPI обычно не идет впереди разработки API.

Иерархическая структура RAML может больше подходить для использования в качестве инструмента проектирования и планирования. Таким образом, RAML может поддерживать подход "сначала спецификация" в большей степени, чем REST. В конечном итоге RAML рекламируется как инструмент "моделирования данных" и "описания" API, в то время как Swagger является последним.

## Не иерархический

Одной из основных концепций стандартов определения API, таких как OpenAPI и RAML, является возможность создавать объекты данных и связывать их между собой. OpenAPI использует для этого схемы и поддерживает встроенные типы данных JSON. RAML использует систему типов для сохранения связанных свойств и содействия повторному использованию в спецификации. Она также поддерживает те же встроенные типы данных, что и OpenAPI.

OpenAPI не имеет "настоящей" иерархической структуры. Что вы хотите получить от иерархической структуры, описывающей ваш API? В идеале вам нужна система для объединения ваших моделей данных, которая будет:

- легко читается/понимается
- позволяет определять отношения между моделями данных с помощью наследования
- уменьшает повторение общих свойств
- максимизирует возможность повторного использования кода

Система типов в RAML более иерархична, чем в REST. Согласно Readme на GitHub, использование в RAML "типов ресурсов и признаков минимизирует повторения в дизайне RESTful API и способствует согласованности внутри и между API". Подробнее о системе типов в RAML мы поговорим далее.

## Не поддерживает наследование модели данных

Объектные типы RAML могут наследовать другие объектные типы. Хотя схемы OpenAPI могут "ссылаться" на схемы, технически они не поддерживают наследование, как это делает RAML. Я говорю "технически", потому что вы можете связать одну схему с другой с помощью ссылки на схему (тег $ref). Однако RAML идет на шаг дальше. Вы можете устанавливать отношения между моделями данных и избегать повторения общих свойств. В OpenAPI схемы не связаны друг с другом иерархически, как в RAML. Типы RAML обладают "истинным" наследованием, когда между моделями данных можно устанавливать отношения "parent-child".

## Не "визуальный" инструмент
Использование типов в качестве моделей данных в RAML делает его более наглядным и легко читаемым, чем OpenAPI. Вы можете легко увидеть взаимосвязь между типами и их общими свойствами.

RAML, как более наглядный инструмент, способствует долгосрочному планированию таких вещей, как имитация ответов сервера, консоли API и многое другое. Также с помощью RAML можно предвидеть и планировать будущие улучшения API.

## Отсутствие поддержки других архитектур

OpenAPI может описывать только RESTful API. Дополнительным преимуществом RAML является поддержка других архитектур, помимо REST, таких как RPC или SOAP, при условии, что они используют протокол HTTP. Гибкость RAML позволяет использовать его в качестве инструмента документирования архитектур, отличных от REST.

# Пример OpenAPI - зоомагазин Swagger
Лучший способ изучить OpenAPI - это практический подход. Некоторые инструменты позволяют редактировать спецификации OpenAPI и затем генерировать документацию по API. Примером документа OpenAPI является спецификация Swagger Petstore.

SwaggerUI - это инструмент, который анализирует определение API для создания документации. SwaggerUI имеет редактор на основе браузера (показан ниже). Вы можете поэкспериментировать с редактором SwaggerUI здесь: https://editor.swagger.io/.

![alt text](/API/Open%20API/image/image3.png)

На левой панели отображается спецификация OpenAPI в формате YAML. Когда вы вносите изменения в спецификацию, эти изменения генерируют новую документацию на правой панели. Правая панель - это документ Swagger, созданный непосредственно на основе спецификации OpenAPI для Petstore (левая панель). Например, изменение описания пути приводит к обновлению документа Swagger с учетом новых изменений.

Если вы посмотрите на спецификацию OpenAPI Swagger слева, то увидите все разделы, описанные в этой статье, включая openapi, info, servers, paths, components, tags и т. д.

Swagger генерирует ошибку, когда вы отклоняетесь от структуры OpenAPI или вводите что-то недопустимое. Обработка ошибок в Swagger подкрепляет концепцию, согласно которой для корректного отображения документации необходимо придерживаться формата OpenAPI. После знакомства с Swagger Petstore вы можете вставить спецификацию другого API в Swagger Editor, чтобы посмотреть, как его информация отображается в SwaggerUI.

В общем, Swagger Editor - это отличный способ познакомиться с тем, как писать определения API и как инструменты анализируют спецификацию для создания документации.