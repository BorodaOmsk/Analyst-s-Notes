# Publisher-Subscriber pattern (pub/sub messaging)


В распределенных архитектурах различные части нашей системы должны предоставлять информацию другим частям по мере возникновения событий. Одним из способов решения этой проблемы является выделение специальных очередей для каждого потребителя и асинхронная отправка сообщений, чтобы отделить их от отправителей. Однако такой способ не подходит для большого количества потребителей, а если некоторые потребители заинтересованы только в части информации, которую отправляют производители.

Ответ на эту проблему можно найти в паттерне Publisher-Subscriber, также известном как pub/sub messaging, где мы можем позволить нашим производителям асинхронно отправлять события подписчикам, не связывая их с отправителями. Pub/Sub messaging - это фундаментальный паттерн для использования в распределенных архитектурах

## Что такое Pub/Sub Messaging?

Обмен сообщениями Pub/Sub позволяет приложениям и производителям асинхронно отправлять события подписчикам без необходимости соединения производителей с отправителями. Отправитель (издатель) использует входной канал для упаковки событий в сообщения, а затем отправляет сообщение. Затем эти сообщения отправляются в выходные каналы обмена сообщениями для каждого потребителя (подписчика), который заинтересован в сообщении. Каждый подписчик получает свою собственную копию сообщения из своего выходного канала.

![alt text](/Integration%20technology/image/Publisher-Subscriber%20pattern/image10.png)

На примере Azure мы можем иметь функцию Azure Function, которая отправляет сообщение в тему Service Bus. У темы может быть несколько подписчиков, и каждый подписчик может быть зарегистрирован в теме. Если у нас есть несколько Azure Functions, выступающих в качестве подписчиков темы, каждый подписчик будет получать свою собственную копию сообщения из темы.

![alt text](/Integration%20technology/image/Publisher-Subscriber%20pattern/image9.png)

Архитектуры, ориентированные на события (Event-driven architectures), работают с производителями событий, генерирующими поток событий, которые прослушивают потребители событий:

![alt text](/Integration%20technology/image/Publisher-Subscriber%20pattern/image8.png)

Архитектуры, ориентированные на события, могут использовать обмен сообщениями pub/sub для отслеживания подписчиков на события. Когда событие публикуется, оно отправляется каждому подписчику. После получения события оно не может быть воспроизведено, и новые подписчики не видят его. Это немного отличается от другого шаблона, называемого потоковой передачей событий, где события записываются в журнал, и вместо того, чтобы потребители подписывались на поток, они могут читать любую часть потока. Это означает, что они могут присоединиться к потоку в любое время и воспроизводить нужные им события. Однако при потоковой передаче событий клиенты сами отвечают за продвижение своей позиции в потоке.

## Каковы преимущества pub/sub messaging?

Обмен сообщениями Pub/Sub помогает нам разделить производителей и потребителей, которым необходимо взаимодействовать. Это помогает нам управлять ими независимо друг от друга, будь то масштабирование производителя для обработки большего количества сообщений или добавление потребителей по мере необходимости. Это также дает нам возможность управлять сообщениями, если потребители находятся в автономном режиме, с помощью самого брокера сообщений.

Такое разделение задач позволяет каждому приложению сосредоточиться на своей основной функциональности, а ответственность за маршрутизацию сообщений к нужному потребителю переложить на брокера сообщений.

Повышается общая надежность нашей архитектуры. Асинхронный обмен сообщениями помогает нашему приложению бесперебойно работать в условиях повышенного трафика и лучше справляться с периодическими сбоями. Тестируемость также повышается, поскольку мы можем проверять наши сообщения в рамках стратегии тестирования.

Подписчикам не обязательно сразу же забирать сообщения из брокера сообщений. В зависимости от требований бизнеса у вас есть возможность забирать сообщения по определенному расписанию.

Поскольку компоненты нашей архитектуры разделены брокером сообщений, интеграция между ними становится проще, поскольку все, что им нужно, - это возможность получать сообщения от брокера сообщений. Это означает, что системы, использующие различные платформы, работающие в облаке или в локальной сети, или различные протоколы программирования, теперь могут более эффективно взаимодействовать друг с другом.

## Что нужно иметь в виду при реализации обмена сообщениями pub/sub?

Если это возможно, избегайте создания собственного сервиса, поддерживающего обмен сообщениями pub/sub. Существует множество продуктов, которые можно использовать для обмена сообщениями pub/sub. В мире Azure для архитектуры pub/sub можно использовать Azure Service Bus, Event Hubs и Event Grid. За пределами Azure возможности pub/sub поддерживают Kafka, Redis и RabbitMQ.

Обмен сообщениями в pub/sub является однонаправленным (движение в одном направлении). Если вам требуется, чтобы подписчики отправляли подтверждение или сообщали статус обратно издателю, лучше использовать паттерн **Request-Reply**.

То, как вы будете работать с подписчиками, будет важным аспектом вашего дизайна. Ваш брокер сообщений должен обеспечивать возможность подписки и отписки для потребителей по мере необходимости. Безопасность подписчиков также должна быть принята во внимание. Безопасное подключение подписчиков к каналу обмена сообщениями очень важно для предотвращения доступа неавторизованных приложений к сообщениям от брокера сообщений.

Также необходимо продумать, как подписчики будут обрабатывать сообщения. Порядок получения сообщений не гарантируется, так же как и порядок их создания. Сообщения также могут быть отправлены более одного раза (в частности, если отправитель не справляется с отправкой сообщения, после чего запускается новый экземпляр отправителя и повторяет сообщение).

Один из способов предотвратить негативные последствия упорядочивания и дублирования в вашей системе - спроектировать логику обработки сообщений таким образом, чтобы она была идемпотентной.

**Метод считается идемпотентным, если предполагаемый эффект для сервера при многократном выполнении одного и того же запроса такой же, как и при выполнении одного запроса.**

В Azure Service Bus есть функция под названием Sessions, которая может заставить сообщения, помеченные одним и тем же идентификатором SessionId, группироваться вместе и доставляться в порядке очереди (FIFO). В данном контексте FIFO означает порядок, в котором сообщения поступали в Service Bus, а не внутренний порядок, который вы хотите соблюдать при обработке сообщений.

![alt text](/Integration%20technology/image/Publisher-Subscriber%20pattern/image7.png)

Еще одной особенностью Service Bus является Message Deferral, которая позволяет обрабатывать сообщения в порядке, который вы определяете, откладывая сообщения с помощью SequenceId.

Другие вопросы, связанные с сообщениями, включают время жизни сообщения (должно ли оно истекать через определенное время?), время обработки сообщения, а также то, должны ли разные сообщения обрабатываться быстрее, чем другие. Если вам необходимо назначить уровень приоритета для определенных сообщений, вы можете рассмотреть возможность реализации шаблона Priority Queue, чтобы гарантировать, что сообщения с более высоким приоритетом будут обрабатываться раньше других.

## В каких ситуациях мы могли бы использовать этот паттерн?

Если у вас есть приложение, которому нужно отправлять сообщения множеству приложений, независимо от того, где они расположены и какой протокол связи используют, паттерн pub/sub будет эффективен для передачи этой информации. Связь Pub/sub идеальна, если вам не нужны ответы от потребителей в реальном времени, и ваша архитектура может поддерживать конечную согласованность.

Однако если в вашей архитектуре всего несколько потребителей, и все они требуют от производителя разной информации, pub/sub вам не поможет. Если вам нужны ответы в реальном времени и взаимодействие между производителем и потребителями, вам стоит рассмотреть альтернативу.

